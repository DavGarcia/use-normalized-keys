# Windows Shift+Numpad Phantom Event Suppression

## Problem Description

On Windows, when a user holds Shift and presses numpad keys, the operating system generates phantom Shift keyup/keydown events that bracket the numpad key press. These phantom events interfere with accurate key state tracking and duration calculations.

### Real-World Example

When a user holds Shift and presses Numpad1, Windows generates this event sequence:

```
16:43:26.283 keydown Shift ShiftLeft [MOD]    ← Real: User presses Shift
16:43:27.440 keyup   Shift ShiftLeft [MOD]    ← PHANTOM: 1ms before numpad
16:43:27.441 keydown 1     Numpad1   [NUM]    ← Real: User presses Numpad1
16:43:27.494 keyup   1     Numpad1   [NUM]    ← Real: User releases Numpad1  
16:43:27.495 keydown Shift ShiftLeft [MOD]    ← PHANTOM: 1ms after numpad
16:43:28.726 keyup   Shift ShiftLeft [MOD]    ← Real: User releases Shift
```

The phantom events at timestamps `27.440` and `27.495` are generated by Windows, not the user. This causes:
- Incorrect duration calculations (showing multiple short Shift presses instead of one long hold)
- State tracking inconsistencies
- Poor user experience in applications relying on accurate key timing

## Our Approach

### Strategy Overview

We use a **timing-based detection system** that tracks recent numpad activity and analyzes Shift events in context to identify and suppress phantom events.

### Key Components

#### 1. Numpad Activity Tracking

```typescript
interface PlatformQuirkState {
  // Track recent numpad events with timestamps
  recentNumpadActivity: Array<{ 
    code: string; 
    type: 'keydown' | 'keyup'; 
    timestamp: number 
  }>;
  // ... other fields
}

function trackNumpadActivity(event: KeyboardEvent, quirkState: PlatformQuirkState): void {
  // Only track numpad keys
  if (!WINDOWS_SHIFT_NUMPAD_KEYS.includes(event.code)) return;
  
  const now = Date.now();
  
  // Add this event to recent activity
  quirkState.recentNumpadActivity.push({
    code: event.code,
    type: event.type as 'keydown' | 'keyup',
    timestamp: now
  });
  
  // Clean up old activity (keep only last 100ms worth)
  quirkState.recentNumpadActivity = quirkState.recentNumpadActivity.filter(
    activity => now - activity.timestamp <= 100
  );
}
```

#### 2. Phantom Event Detection Logic

```typescript
function isLikelyPhantomShiftEvent(
  event: KeyboardEvent, 
  quirkState: PlatformQuirkState,
  currentKeyStates: Map<string, any>
): boolean {
  const now = Date.now();
  const PHANTOM_WINDOW_MS = 20; // Phantom events happen within 20ms of numpad events
  
  // Check if there's recent numpad activity
  const hasRecentNumpadActivity = quirkState.recentNumpadActivity.some(activity => {
    const timeDiff = Math.abs(now - activity.timestamp);
    return timeDiff <= PHANTOM_WINDOW_MS;
  });
  
  // For keyup events: phantom if Shift is still physically held
  if (event.type === 'keyup') {
    const isShiftStillHeld = event.getModifierState('Shift');
    
    // Recent numpad activity + Shift still held = phantom keyup
    if (isShiftStillHeld && (hasRecentNumpadActivity || quirkState.recentNumpadActivity.length > 0)) {
      return true;
    }
    
    // Fallback: Check if numpad keys are currently tracked as down
    const hasNumpadKeyDown = Array.from(currentKeyStates.entries()).some(([trackedKey, state]) => {
      if (!state?.isDown) return false;
      
      const numpadDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
      const numpadNavigation = ['Insert', 'End', 'ArrowDown', 'PageDown', 'ArrowLeft', 
                                'Clear', 'ArrowRight', 'Home', 'ArrowUp', 'PageUp', 'Delete'];
      const numpadOperators = ['+', '-', '*', '/', '.', 'Enter'];
      
      return numpadDigits.includes(trackedKey) || 
             numpadNavigation.includes(trackedKey) ||
             numpadOperators.includes(trackedKey);
    });
    
    return isShiftStillHeld && hasNumpadKeyDown;
  }
  
  // For keydown events: phantom if follows recent numpad activity
  if (event.type === 'keydown') {
    const hasRecentNumpadKeyup = quirkState.recentNumpadActivity.some(activity => {
      const timeDiff = Math.abs(now - activity.timestamp);
      return activity.type === 'keyup' && timeDiff <= PHANTOM_WINDOW_MS;
    });
    
    const isInSuppressionMode = quirkState.windowsShiftSuppressionActive;
    const shiftAlreadyTracked = currentKeyStates.get('Shift')?.isDown;
    
    return (hasRecentNumpadKeyup || isInSuppressionMode) && 
           event.getModifierState('Shift') && 
           shiftAlreadyTracked;
  }
  
  return false;
}
```

#### 3. Main Suppression Function

```typescript
export function shouldSuppressWindowsShiftPhantom(
  event: KeyboardEvent,
  currentKeyStates: Map<string, any>,
  quirkState: PlatformQuirkState
): boolean {
  // Only apply on Windows
  if (!Platform.isWin) return false;
  
  // Track numpad activity for all events
  trackNumpadActivity(event, quirkState);
  
  // Only handle Shift key events for suppression
  if (event.key !== 'Shift') return false;
  
  // Check if this is a phantom event based on timing and modifier state
  const isPhantom = isLikelyPhantomShiftEvent(event, quirkState, currentKeyStates);
  
  if (isPhantom) {
    console.log(`[platformQuirks] Suppressing Windows Shift+Numpad phantom ${event.type} event`);
    
    // Set suppression mode for follow-up phantom events
    if (event.type === 'keyup') {
      quirkState.windowsShiftSuppressionActive = true;
    } else if (event.type === 'keydown') {
      quirkState.windowsShiftSuppressionActive = false; // Clear after phantom keydown
    }
    
    return true;
  }
  
  // Clear suppression mode on real Shift keyup
  if (event.type === 'keyup' && !event.getModifierState('Shift')) {
    quirkState.windowsShiftSuppressionActive = false;
  }
  
  return false;
}
```

### How It Works

#### Detection Criteria

1. **Platform Check**: Only applies on Windows systems
2. **Timing Analysis**: Looks for Shift events within 20ms of numpad activity
3. **Physical State Verification**: Uses `event.getModifierState('Shift')` to determine if Shift is actually pressed
4. **Context Awareness**: Considers current key states and recent activity patterns

#### For Phantom Keyup Events
- **Condition**: Shift keyup event where `getModifierState('Shift')` returns `true`
- **Logic**: If Shift is still physically held but we're getting a keyup event, it's phantom
- **Additional Check**: Must occur near numpad activity or have numpad keys currently pressed

#### For Phantom Keydown Events  
- **Condition**: Shift keydown when Shift is already tracked as pressed
- **Logic**: If we recently had numpad keyup activity and Shift is still held, the keydown is phantom
- **State Management**: Uses suppression mode flag from previous phantom keyup detection

### Integration Points

The phantom suppression is integrated into the main hook at the event processing level:

```typescript
// In updateKeyState function
if (shouldSuppressWindowsShiftPhantom(event, keyStates, quirks)) {
  debugCountersRef.current.quirksHandled++;
  if (debug) {
    console.log('[useNormalizedKeys] Suppressed Windows Shift+Numpad phantom event');
  }
  return; // Don't process this phantom event
}
```

### Testing Strategy

#### Unit Tests
- Simulate the exact phantom event sequence from Windows
- Verify suppression occurs for phantom events
- Ensure real events are not suppressed
- Test edge cases and timing variations

#### Integration Tests  
- Test within the full hook context
- Verify duration calculations remain accurate
- Ensure state consistency throughout phantom sequences

#### Real-World Validation
- Browser testing on Windows with actual Shift+Numpad combinations
- Verification that event history shows clean sequences without phantom events
- Performance testing to ensure minimal overhead

### Timing Considerations

#### Windows Phantom Event Timing
- Phantom events typically occur within **1-5ms** of numpad events
- Our detection window is set to **20ms** for compatibility with test environments
- Real-world timing is much more precise than test simulation

#### Performance Impact
- Minimal overhead: only processes Shift events and tracks numpad activity
- Memory efficient: automatically cleans up old activity data
- No impact on non-Windows platforms or non-numpad usage

### Limitations and Assumptions

#### Current Limitations
1. **Timing Dependent**: Relies on consistent Windows phantom event timing
2. **Windows Specific**: Only addresses Windows platform quirks
3. **Numpad Focused**: Specifically designed for numpad-related phantom events

#### Assumptions
1. Windows phantom events maintain consistent timing patterns across versions
2. `getModifierState()` accurately reflects physical key state
3. Phantom events always occur in keyup→keydown pairs around numpad activity

### Future Improvements

#### Potential Enhancements
1. **Adaptive Timing**: Learn and adjust timing windows based on observed patterns
2. **Pattern Recognition**: Develop more sophisticated phantom event signatures  
3. **Cross-Platform**: Extend to handle similar issues on other platforms
4. **Performance Optimization**: Further reduce memory footprint and CPU usage

#### Monitoring and Debugging
- Debug logging provides detailed phantom event detection information
- Performance counters track suppressed events
- State inspection available for troubleshooting

## Conclusion

This timing-based approach successfully identifies and suppresses Windows Shift+Numpad phantom events by:

1. **Tracking Context**: Maintaining awareness of recent numpad activity
2. **Analyzing Timing**: Using precise timing windows to detect phantom patterns
3. **Verifying Physical State**: Leveraging browser APIs to confirm actual key states
4. **Maintaining Compatibility**: Working in both test and real-world environments

The solution provides clean, accurate key event streams for applications requiring precise keyboard input handling while maintaining excellent performance and minimal overhead.